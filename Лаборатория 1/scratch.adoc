:imagesdir: images

[.text-center]
МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ РОССИЙСКОЙ ФЕДЕРАЦИИ +
Федеральное государственное автономное образовательное учреждение
высшего образования +
«Южно-Уральский государственный университет» +
(национальный исследовательский университет) +
Высшая школа электроники и компьютерных наук +
Кафедра «Информационно-измерительная техника»

[.text-center]
Отчет по лабораторной работе №0 +

[.text-right]
Выполнил: +
студент группы КЭ-415 +
Федотов Н.А.

[.text-right]
Проверил:доцент +
Колодий С.В.

[.text-center]
Челябинск 2021


== Оглавление

:toc-title:

 1. СОЗДАНИЕ ПРОЕКТА В IAR WORKBENCH

 2. ВЫБОР ШАБЛОНА ПРОЕКТА

 3. ВЫБОР МИКРОКОНТРОЛЛЕРА

 .. STM32F4

 .. STM32F411

 .. ST STM32F411RE

 4. КОД ПРОГРАММЫ

 5. ВЫВОД РЕЗУЛЬТАТА В TERMINAL I/O

 6. ПРОЕКТ В РЕЖИМЕ СИМУЛЯЦИИ

 7. ЗАПУСК ОКНА REGISTERS

 8. ОТВЕТЫ НА ВОПРОСЫ

=== Задание
Создать проект *Lab1* под микроконтроллер *STM32F411RE* в IDE *IAR Embedded Workbench*, затем написать код программы, которая считает сумму двух *char* чисел (например *1* и *-6*, *10* и *250*). Также проверить все переменные в окне watch, сделать пошаговую отладку (F10, F11), посмотреть, как меняются переменные в окне Watch. заупустить окно Resisters и посмотреть значения регистров в которых созданы переменные.

=== Создадим проект в IAR Workbench
* Создадим новый проект Project => Create New Project (рисунок 1).

.Создание нового проекта
image::image-2021-09-23-22-58-57-254.png[]

=== Выберем шаблон проекта
* ProjectTemplates: C++ => main (рисунок 2).

.Выбор шаблона проекта
image::image-2021-09-23-23-00-10-549.png[]

=== Выберем микроконтроллер
* Сохраним проект под любым именем, например project1.
* В свойствах проекта выберем модель микроконтроллера ST => STM32F4 => STM32F411 => ST STM32F411RE (рисунок 3). Для этого правой кнопкой мыши щелкнем по проекту, выберем Options и далее в категории General Option выберем вкладку Target.

.Выбор модели микроконтроллера
image::image-2021-09-23-23-01-33-558.png[]


=== Код программы
Напишем код программы, которая считает сумму двух *char* чисел (*1* и *-6*, *10* и *250*). Код программы, представленный на рисунке 4, будет записан в функцию main - функцию, с которой начинается программа.

#include <iostream>

int main()

{

char i = 1;

char j = -6;

char result = i + j;

std::cout << static_cast<int>(result) << std::endl;

char k = 10;

char m = 250;

char result1 = k + m;

std::cout << static_cast<int>(result1) << std::endl;

return 1;

}



=== Вывод результата в Terminal I/O
*Terminal I/O* - это подобие консоли, в которой можно наблюдать за результатом вывода программы. Чтобы отобразить окно Terminal I/O необходимо запустить код в режиме отладки *Ctrl+D* и затем в окне *View* выбрать *Terminal I/O* (рисунок 4).

.Подключение окна Terminal I/O
image::image-2021-09-23-23-20-53-557.png[]


Запустим код в режиме отладки и проверим результат нашей программы в окне *Terminal I/O* (рисунок 5).

.Вывод результатов в окне Terminal I/O
image::image-2021-09-23-23-21-22-679.png[]

char - является переменной (8-битной). Поэтому содержит числа 0,1,2...255 и не включает в себя отрицательные числа. Возьмем 1 пример: (1+(-6)), мы видим что при сложении получается отрицательное число, а в переменной char - их нет, то следует, что при сложении чисел мы получим 251. То есть, при достижении нуля, нам следует отнять число от 255.

Пример 2: (250+10), такая же ситуация, что и в первом примере, мы видим, что при сложении чисел получается 260, но оно не входит в переменную char, таким образом, мы начинаем отсчет с самого первого числа, то есть с 0, в итоге мы получаем 4.

=== Запуск проекта в режим симуляции
По умолчанию загрузка и отладка бинарного файла осуществляется в симулятор выбранного микроконтроллера, показанное на рисунке 6.

.Проект в режиме отладки
image::image-2021-09-23-23-26-34-810.png[]


На этом рисунке можено увидеть, как сам код написанный на С++, так и окно дизассемблера, показывающее как компилятор преобразовал код в команды

ассемблера. Зеленая строчка показывает текущую исполняющую строчку вашего кода и команду ассемблера. При нажатии на кнопку *F10* или *F11* мы переходим наже как по строчкам кода, так и по окну дизассемблера и можем в нем определять где создались наши переменные.

Для того чтобы остановить отладку и выйти в режим разработки необходимо нажать кнопки Ctrl+Shift+D.

=== Окно Registers


В окне *Registers* можно просматривать значения регистров в которых созданы переменные (при условии, что они там созданы). Чтобы это окно нужно нажать в режиме отладки во вкладке *View* на строчку *Registers* (рисунок 7).

.Просмотр регистров в окне Registers
image::image-2021-09-23-23-27-35-556.png[]

Аналогично окну *Watch* можно просматривать изменение регистров пройдясь по коду клавишами *F10* или *F11*.


*Ответы на вопросы первого раздела*

[qanda]
*1.* Дайте определение понятию “Интегрированной среде разработки”

Ответ:
Интегрированная среда разработки (IDE) - система программных средств, используемая программистами для разработки программного обеспечения.

Включает в себя:
⦁ текстовый редактор;
⦁ компилятор;
⦁ средства автоматизации сборки;


*2.* Что такое компилятор и чем он отличается от транслятора?

Ответ:
Компилятор - программа выполняющая трансляцию исходного кода из предметно-ориентированногоязыка на мишинно-ориентированный язык.
Транслятор - это программа-переводчик. Она преобразует программу, написанную на одном из языков высокого уровня, в программу, состоящую из машинных команд.
Компилятор отличается от транслятора  тем, что его результирующая программа всегда должна быть написана на языке машинных кодов или на языке ассемблера.

*3.* Что такое компоновщик и какие функции он выполняет?

Ответ:
Компоновщик — инструментальная программа, которая производит компоновку («линковку»): принимает на вход один или несколько объектных модулей и собирает из них исполняемый или библиотечный файл-модуль.

*4.* Почему важен процесс проектирования ПО какие задачи входят в этот процесс?

Ответ: процесс проектирования ПО важен потому, так как при его создании происходит структурирование действий каждого отдела какой-либо фирмы.


*5.* Дорисуйте процесс разработки ПО, описанный на изображении *IAR_Workbench* с учетом итеративности связей в этом процессе

Ответ: по моему мнению, в данный процесс разработки ПО, необходимо добавить документацию по программногму обеспечанию, а также завершение всей стадии разработки.


*6.* Зачем нужна отладка и в каких случаях она применяется? Для чего применяются точки остановки?

Ответ: отладка необходима для поиска различных ошибок и багов, которые возникают в коде.

*7.* Какие еще важные характеристики IAR Workbench можно добавить в таблицу *Характеристики IAR*

Ответ: я считаю, что одной из важной характеристикой, которую можно добавить в в таблицу характеристик - это пошаговая отладка.


