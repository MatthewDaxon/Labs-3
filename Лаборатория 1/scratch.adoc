:imagesdir: images
== Лабораторная работа №0

= Оглавление

:toc-title:

 1. СОЗДАНИЕ ПРОЕКТА В IAR WORKBENCH

 2. ВЫБОР ШАБЛОНА ПРОЕКТА

 3. ВЫБОР МИКРОКОНТРОЛЛЕРА

 .. STM32F4

 .. STM32F411

 .. ST STM32F411RE

 4. КОД ПРОГРАММЫ

 5. ВЫВОД РЕЗУЛЬТАТА В TERMINAL I/O

 6. ПРОЕКТ В РЕЖИМЕ СИМУЛЯЦИИ

 7. ЗАПУСК ОКНА REGISTERS

 8. ОТВЕТЫ НА ВОПРОСЫ

=== Задание
Создать проект *Lab1* под микроконтроллер *STM32F411RE* в IDE *IAR Embedded Workbench*, затем написать код программы, которая считает сумму двух *char* чисел (например *1* и *-6*, *10* и *250*). Также проверить все переменные в окне watch, сделать пошаговую отладку (F10, F11), посмотреть, как меняются переменные в окне Watch. заупустить окно Resisters и посмотреть значения регистров в которых созданы переменные.

=== Создадим проект в IAR Workbench
* Создадим новый проект Project => Create New Project (рисунок 1).

.Создание нового проекта
image::image-2021-09-23-22-58-57-254.png[]

=== Выберем шаблон проекта
* ProjectTemplates: C++ => main (рисунок 2).

.Выбор шаблона проекта
image::image-2021-09-23-23-00-10-549.png[]

=== Выберем микроконтроллер
* Сохраним проект под любым именем, например project1.
* В свойствах проекта выберем модель микроконтроллера ST => STM32F4 => STM32F411 => ST STM32F411RE (рисунок 3). Для этого правой кнопкой мыши щелкнем по проекту, выберем Options и далее в категории General Option выберем вкладку Target.

.Выбор модели микроконтроллера
image::image-2021-09-23-23-01-33-558.png[]


=== Код программы
Напишем код программы, которая считает сумму двух *char* чисел (*1* и *-6*, *10* и *250*). Код программы, представленный на рисунке 4, будет записан в функцию main - функцию, с которой начинается программа.

#include <iostream>

int main()

{

char i = 1;

char j = -6;

char result = i + j;

std::cout << static_cast<int>(result) << std::endl;

char k = 10;

char m = 250;

char result1 = k + m;

std::cout << static_cast<int>(result1) << std::endl;

return 1;

}



=== Вывод результата в Terminal I/O
*Terminal I/O* - это подобие консоли, в которой можно наблюдать за результатом вывода программы. Чтобы отобразить окно Terminal I/O необходимо запустить код в режиме отладки *Ctrl+D* и затем в окне *View* выбрать *Terminal I/O* (рисунок 5).

.Подключение окна Terminal I/O
image::image-2021-09-23-23-20-53-557.png[]


Запустим код в режиме отладки и проверим результат нашей программы в окне *Terminal I/O* (рисунок 6).

.Вывод результатов в окне Terminal I/O
image::image-2021-09-23-23-21-22-679.png[]

Полученные результаты объясняются тем, что переменная *char* - 8-битное число, то есть ее вместимость 256 символов от 0 до 255. При сложении 1 + (-6) получаем число равное -5, но в переменной *char* такого числа нет и она уменьшается с конца, значит получаем число 251.

=== Запуск проекта в режим симуляции
По умолчанию загрузка и отладка бинарного файла осуществляется в симулятор выбранного микроконтроллера, показанное на рисунке 7.

.Проект в режиме отладки
image::image-2021-09-23-23-26-34-810.png[]


На этом рисунке можено увидеть, как сам код написанный на С++, так и окно дизассемблера, показывающее как компилятор преобразовал код в команды

ассемблера. Зеленая строчка показывает текущую исполняющую строчку вашего кода и команду ассемблера. При нажатии на кнопку *F10* или *F11* мы переходим наже как по строчкам кода, так и по окну дизассемблера и можем в нем определять где создались наши переменные.

Для того чтобы остановить отладку и выйти в режим разработки необходимо нажать кнопки Ctrl+Shift+D.

=== Окно Registers


В окне *Registers* можно просматривать значения регистров в которых созданы переменные (при условии, что они там созданы). Чтобы это окно нужно нажать в режиме отладки во вкладке *View* на строчку *Registers* (рисунок 8).

.Просмотр регистров в окне Registers
image::image-2021-09-23-23-27-35-556.png[]

Аналогично окну *Watch* можно просматривать изменение регистров пройдясь по коду клавишами *F10* или *F11*.


*Ответы на вопросы первого раздела*

[qanda]
*1.* Дайте определение понятию “Интегрированной среде разработки”

Ответ:
Интегрированная среда разработки (IDE) - система программных средств, используемая программистами для разработки программного обеспечения.

Включает в себя:
⦁ текстовый редактор;
⦁ компилятор;
⦁ средства автоматизации сборки;


*2.* Что такое компилятор и чем он отличается от транслятора?

Ответ:
Компилятор - программа выполняющая трансляцию исходного кода из предметно-ориентированногоязыка на мишинно-ориентированный язык.
Транслятор - это программа-переводчик. Она преобразует программу, написанную на одном из языков высокого уровня, в программу, состоящую из машинных команд.
Компилятор отличается от транслятора  тем, что его результирующая программа всегда должна быть написана на языке машинных кодов или на языке ассемблера.

*3.* Что такое компоновщик и какие функции он выполняет?

Ответ:
Компоновщик — инструментальная программа, которая производит компоновку («линковку»): принимает на вход один или несколько объектных модулей и собирает из них исполняемый или библиотечный файл-модуль.

*4.* Почему важен процесс проектирования ПО какие задачи входят в этот процесс?

Ответ: процесс проектирования ПО важен потому, так как при его создании происходит структурирование действий каждого отдела какой-либо фирмы.
Процесс проектирования ПО включает следующие задачи:
⦁ документирование ПО;
⦁ выбор метода и стратегии решения;
⦁ разработка основного алгоритма;
⦁ выбор представления внутренних данных;


*5.* Дорисуйте процесс разработки ПО, описанный на изображении *IAR_Workbench* с учетом итеративности связей в этом процессе

Ответ:




*6.* Зачем нужна отладка и в каких случаях она применяется? Для чего применяются точки остановки?

Ответ: отладка необходима для поиска различных ошибок и багов, которые возникают в коде.

*7.* Какие еще важные характеристики IAR Workbench можно добавить в таблицу *Характеристики IAR*

Ответ:.


